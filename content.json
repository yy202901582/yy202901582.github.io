{"meta":{"title":"neko","subtitle":null,"description":null,"author":"neko","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"github的认识与使用","text":"文章链接1文章链接2","path":"2020/02/27/github的认识与使用/","date":"02-27","excerpt":"","tags":[]},{"title":"git上传文件","text":"链接","path":"2020/02/27/git上传文件/","date":"02-27","excerpt":"","tags":[]},{"title":"problem","text":"1找到长度的最小数目N，使得所有数字同时整除2,3,5,7,数字的长度是其十进制表示形式中没有前导零的位数。输入值：单个输入线包含一个整数Ñ（1≤ N≤10^5）。输出量：打印单个整数-不带前导零的问题答案，如果不存在满足问题条件的数字，则打印“ -1 ”（不带引号）。 123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;public class TestMain &#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); int last = input.nextInt(); int h; if(last&lt;3)&#123; System.out.println(-1); &#125;else if(last==3)&#123; System.out.println(210); &#125;else&#123; String[] list; list = new String[7]; list[0] = &quot;&quot;; for(int a=4;a&lt;4+6;a++) &#123; int x=0; h = 10*((int)Math.pow(10, a-2)+2+x*3); while(h%7!=0) &#123; x++; h = 10*((int)Math.pow(10, a-2)+2+x*3); &#125; h = 10*(2+x*3); list[a-3] = Integer.toString(h); &#125; list[0] =list[6]; String count=&quot;1&quot;; for(int c = 1;c&lt;last-list[(last-3)%6].length();c++)&#123; count = count+&quot;0&quot;; &#125; count = count+list[(last-3)%6]; System.out.println(count); &#125; &#125;&#125; 2题目 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.ArrayDeque;import java.util.Queue;public class TestM1 &#123; public static void main(String[] args)&#123; int[][] orange1 = &#123;&#123;0,2,2&#125;&#125;; Solution S = new Solution(); int num = S.orangesRotting(orange1); System.out.println(num); &#125;&#125;class Solution &#123; public int orangesRotting(int[][] orange1) &#123; int[] a = &#123;1, -1,0,0&#125;;int[] b = &#123;0, 0,1,-1&#125; ; int step = 0; Queue&lt;int[]&gt; queue; queue = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; orange1.length; i++) &#123; for (int j = 0; j &lt; orange1[0].length; j++) &#123; if(orange1[i][j]==2)queue.offer(new int[]&#123;i, j&#125;); &#125; &#125; while (!queue.isEmpty())&#123; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; int[] temp = queue.poll(); for (int j = 0; j &lt; a.length; j++) &#123; int x = temp[0] + a[j]; int y = temp[1] + b[j]; if( x&gt;=0 &amp;&amp; x&lt;orange1.length &amp;&amp; y&gt;=0 &amp;&amp; y&lt;orange1[0].length &amp;&amp; orange1[x][y] == 1)&#123; orange1[x][y] = 2; queue.offer(new int[]&#123;x,y&#125;); &#125; &#125; &#125; if(!queue.isEmpty())&#123; step++; &#125; &#125; for (int i = 0; i &lt; orange1.length; i++) &#123; for (int j = 0; j &lt; orange1[0].length; j++) &#123; if(orange1[i][j]==1)&#123; return -1; &#125; &#125; &#125; return step; &#125;&#125; quene队列相关参考文档 没有实现的阻塞接口的LinkedList： 内置的不阻塞队列： PriorityQueue 和 ConcurrentLinkedQueue 实现阻塞接口的： ArrayBlockingQueue ：一个由数组支持的有界队列。 LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。 PriorityBlockingQueue ：一个由优先级堆支持的无界优先级队列。 DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。 SynchronousQueue ：一个利用 BlockingQueue 接口的简单聚集（rendezvous）机制。 quene. add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true 如果队列已满，则返回false poll 移除并返问队列头部的元素 如果队列为空，则返回null peek 返回队列头部的元素 如果队列为空，则返回null put 添加一个元素 如果队列满，则阻塞 take 移除并返回队列头部的元素 如果队列为空，则阻塞 BFS相关 广度优先算法（Breadth-First-Search）初始化队列quene；quene={起点}；标记起点已访问；while(quene not null){取队首元素e1；//e1出队if（e1符合条件）{...操作}；所有与e1相邻且未访问节点进入队列；标记e1已访问；}","path":"2020/02/26/problem/","date":"02-26","excerpt":"","tags":[]},{"title":"Spring初试","text":"","path":"2020/02/26/Spring初试/","date":"02-26","excerpt":"","tags":[]},{"title":"markdown文件","text":"markdown文件百科Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。Markdown 编写的文档后缀为 .md .markdown。 语法标题:123456# h1 标题## h2 标题### h3 标题#### h4 标题##### h5 标题###### h6 标题 h1 标题h2 标题h3 标题h4 标题h5 标题h6 标题分割线:你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： 1234***___--- 字体:Markdown 可以使用以下几种字体： 123456*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___ 斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本 删除线:文字的两端加上两个波浪线 ~~ 即可，如下： 1~~万千星辉不及你~~ 万千星辉不及你 下划线：1&lt;u&gt;带下划线文本&lt;/u&gt; 带下划线文本 列表Markdown 支持有序列表和无序列表。无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记： 123456+ 1+ 2* 3* 4- 5- 6 1 2 3 4 5 6区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：12345* 第一项 &gt; 111 &gt;&gt; 222 &gt;&gt;&gt; 333* 第二项 第一项 111 222 333 第二项链接12[baidu](https://www.baidu.com/)&lt;https://www.baidu.com/&gt; baiduhttps://www.baidu.com/ 链接的其他方式 123这个链接用 1 作为网址变量 [Google][1]-----------------------[1]: http://www.google.com/ 这个链接用 1 作为网址变量 Google脚注1234创建脚注格式类似这样 [^TEXT]。[^TEXT]: 脚注的内容 创建脚注格式类似这样 ^TEXT。 图片12![示例](https://static-event.benghuai.com/new_mihoyo_homepage/images/download/cg/origin/2018-10-18.jpg)&lt;img src=&quot;https://static-event.benghuai.com/new_mihoyo_homepage/images/download/cg/origin/2018-10-18.jpg&quot;&gt; 表格123456789| 表头 | 表头 || ---- | ---- || 1 | 1 || 1 | 1 || 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 1 | 1 | 1 || 1 | 1 | 1 | 表头 表头 1 1 1 1 左对齐 右对齐 居中对齐 1 1 1 1 1 1 转义Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\\ 反斜线` 反引号* 星号_ 下划线&#123;&#125; 花括号[] 方括号() 小括号# 井字号+ 加号- 减号. 英文句点! 感叹号 如: \\ ` ! * _ () 支持的html元素目前支持的 HTML 元素有： 等 1使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 使用 Ctrl+Alt+Del 重启电脑 流程图123456781、横向流程图源码格式：```mermaidgraph LRA[方形] --&gt;B(圆角) B --&gt; C&#123;条件a&#125; C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 2、竖向流程图源码格式： 123456graph TDA[方形] --&gt; B(圆角) B --&gt; C&#123;条件a&#125; C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图]","path":"2019/10/23/md文件书写规范/","date":"10-23","excerpt":"","tags":[]}]}